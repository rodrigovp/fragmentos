<html><head><title>Permanent Link to Exemplos Simples</title><meta charset="utf-8"></head><body><h2>Permanent Link to Exemplos Simples</h2><p>A partir do momento que você resolve utilizar uma tecnologia deve fazer o possível para entendê-la. Hoje eu estava conversando com um amigo e percebi que por mais que estejam espalhados os conceitos ainda não são entendidos. Falávamos sobre <a href="http://web.archive.org/web/20090211221146/http://java.sun.com/developer/technicalArticles/J2EE/jpa/">JPA</a> e sobre como misturar lógica de negócios com metadados de persistência pode se tornar um problema em longo prazo. O argumento em favor da mistura foi “mas sua lógica de negócios não precisa ficar anotada, apenas seus dados”. Aí eu percebi que a discussão, na verdade, precisava passar por algo mais fundamental.</p><p>Eu expliquei o problema de usar <a href="http://web.archive.org/web/20090211221146/http://fragmental.com.br/wiki/index.php?title=Evitando_VOs_e_BOs">VOs e BOs</a> (que ele não chamava por estes nomes mas aplicava <a href="http://web.archive.org/web/20090211221146/http://fragmental.com.br/wiki/index.php?title=Fantoches">os conceitos</a>) através de um exemplo simples.</p><p>Vamos supôr que exista uma função que define o novo salário de um funcionário (pseudo-codigo):<br> <code><br> public void aumentaSalario(Funcionario f, Valor v){<br> Valor salario = v + calculaTaxasCargo(f.getCargo());<br> f.setSalario(salario);<br> }<br> </code><br> E vamos supor que exista um tipo de funcionário chamado <code>Gerente</code>. O Gerente possui uma lógica de cálculo de salário um pouco diferente, dada pela formula:<br> <code><br> salario = v + calculaTaxasCargo(f.getCargo()) + (f.getDepartamento().getOrcamento().getBonus() / 10)<br> </code></p><p>Como adaptamos o código acima para que isso seja possível? Uma forma é criar um novo método:<br> <code><br> public void aumentaSalario(Funcionario f, Valor v){<br> Valor salario = v + calculaTaxasCargo(f.getCargo());<br> f.setSalario(salario);<br> }<br> public void aumentaSalarioGerente(Gerente f, Valor v){<br> Valor salario = calculaSalario(f,v) + (f.getDepartamento().getOrcamento().getBonus() / 10);<br> f.setSalario(salario);<br> }<br> </code><br> Mas desta forma nós sempre precisamos saber se estamos lidando com um gerente ou funcionário para saber qual função chamar. Se temos uma lista como a abaixo (que pode ser retornada do banco de dados, por exemplo) precisamos verificar cada tipo:<br> <code><br> List&lt;Funcionario&gt; lista = new ArrayList&lt;Funcionario&gt;();<br> .<br> lista.add(new Gerente("João"));<br> lista.add(new Funcionario("Lucia"));<br> .<br> //aumentando o salario de todo mundo em 1000 dinheiros<br> for(Funcionario f: lista){<br> if(f instanceof Gerente){<br> aumentaSalarioGerente(f,1000);<br> }<br> else{<br> aumentaSalario(f,1000);<br> }<br> }<br> </code><br> De que adianta ter uma abstração na forma de herança entre Funcionario e Gerente se cada vez que eu preciso manipulá-las eu preciso quebrar esta abstração com um <code>if</code>? Ok, é fácil de resolver isso criando uma função única:<br> <code><br> public void aumentaSalario(Funcionario f, Valor v){<br> Valor salario = v + calculaTaxasCargo(f.getCargo());<br> .<br> if(f instanceof Gerente){<br> salario = calculaSalario(f,v) + (f.getDepartamento().getOrcamento().getBonus() / 10);<br> }<br> f.setSalario(salario);<br> }<br> .<br> //Aumentando salarios:<br> List&gt;Funcionario&gt; lista = new ArrayList&gt;Funcionario&gt;);<br> .<br> lista.add(new Gerente("João"));<br> lista.add(new Funcionario("Lucia"));<br> .<br> //aumentando o salario de todo mundo em 1000 dinheiros<br> for(Funcionario f: lista){<br> aumentaSalario(f,1000);<br> }<br> </code><br> Mas o que eu fiz foi simplesmente mudar o problema de lugar, não acabar com ele (por isso <a href="http://web.archive.org/web/20090211221146/http://fragmental.com.br/blog/?p=313">minha métrica do if</a>).</p><p>E qual a solução? Polimorfismo.<br> <code><br> class Funcionario{<br> .<br> public void aumentaSalario(Valor v){<br> Valor salario = v + calculaTaxasCargo(this.getCargo());<br> this.salario = salario;<br> }<br> .<br> }<br> .<br> class Gerente extends Funcionario{<br> .<br> public void aumentaSalario(Valor v){<br> super.aumentaSalario(v);<br> //soma o bonus de gerente ao salario<br> f.setSalario(salario);<br> this.salario = this.salario+ (getDepartamento().getOrcamento().getBonus() / 10);<br> }<br> .<br> }<br> </code><br> Daí nossa lista de aumento em massa pode fazer simplesmente:<br> <code><br> //Aumentando salarios:<br> List&gt;Funcionario&gt; lista = new ArrayList&gt;Funcionario&gt;();<br> .<br> lista.add(new Gerente("João"));<br> lista.add(new Funcionario("Lucia"));<br> .<br> //aumentando o salario de todo mundo em 1000 dinheiros<br> for(Funcionario f: lista){<br> f.aumentaSalario(1000);<br> }<br> </code><br> Porque cada objeto tem em si a lógica necessária para realizar a operação. Claro que este é um exemplo acadêmico, já identifiquei uma penca de refactorings necessários para o código ficar aceitável, mas a idéia está expressa nessa simples divisão de responsabilidade.</p><p>Aí é hora de alguém postar um comentário dizendo: “mas estes objetos ‘gordos’ têm toda a lógica? Fazem persistência?” a resposta é <strong>não</strong>. Objetos são ‘animais sociais e colaborativos’, o que significa que eles agem em conjunto com outros objetos para chegar a um fim. No exemplo acima, o cálculo sobre quanto é o bônus não é feito pelo funcionário, nem pelo gerente mas sim sobre quem é “dono” do conceito (dica: esta parte pode ser refatorada se você ler sobre o <em>Princípio de Deméter</em>).</p><p>Objetos dividem as responsabilidades e agem em conjunto para executar as regras de negócio de um sistema. Parece simples mas cada vez mais eu acho que as pessoas não gostam de conceitos simples :(</p></body></html>