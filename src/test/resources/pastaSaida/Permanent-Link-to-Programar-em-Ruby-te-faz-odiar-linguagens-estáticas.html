<html><head><title>Permanent Link to Programar em Ruby te faz odiar linguagens estáticas</title><meta charset="utf-8"></head><body><h2>Permanent Link to Programar em Ruby te faz odiar linguagens estáticas</h2><p>Papo interessante que estava tendo com o <a href="http://web.archive.org/web/20090212110954/http://www.guj.com.br/user/profile/3136.java">Fabrício </a>ainda agora…</p><p> fabrício diz:<br> hehehhe<br> vc tb ta estudando ruby ?<br> Phillip Calçado - All that’s sacred..comes from youth! diz:<br> sim</p><p> fabrício diz:<br> pq ?</p><p> Phillip Calçado - All that’s sacred..comes from youth! diz:<br> por que eh uma linguagem *muito* boa<br> produtiva e de qualidade</p><p> fabrício diz:<br> rapaz..<br> hehe<br> sacanagem, mas eu quero saber o q eh q vcs acharam tao extraordinario nessa linguagem<br> eu vi aquele videozinho</p><p> Phillip Calçado - All that’s sacred..comes from youth! diz:<br> closures, dinamismo, DSLs</p><p> fabrício diz:<br> realmente me surprendi</p><p> Phillip Calçado - All that’s sacred..comes from youth! diz:<br> hoje eu estava com um problema interessante em java</p><p> fabrício diz:<br> qual ?</p><p> Phillip Calçado - All that’s sacred..comes from youth! diz:<br> tem uma classe qualquer que cria um objeto que pode ser considerado uma sessão com o banco de dados<br> só que numa jvm só podem existir duas sessões ao mesmo tempo, em threads diferentes<br> e me foi pedido para toda vez que se tenta abrir uma dessas, logar num arquivo antes quantas existem em memoria<br> para saber se estavamos tendo muito problema com isso ou se quase nunca duas sessoes ficam abertas<br> o jeito mais simples seria colocar uma variavel de classes (estatica) na classe que cria a conexão para saber quantas ela criou, certo?</p><p> fabrício diz:<br> é, a principio sim<br> e aii ?</p><p> Phillip Calçado - All that’s sacred..comes from youth! diz:<br> mas o problema eh que a classe que pede para essa outra criar uma sessão é quem fecha a sessão<br> então nós poderíamos saber quantas ssessões foram criadas, mas não quando uma for fechada<br> e essa classe sessão é do fornecedor do banco de dados, ou seja não pode ser alterada<br> como resolver isso em java?</p><p> fabrício diz:<br> unh … sem alterar a classe do fornecedor do bd, acho q tem q queimar um pouco os neuronios hehe<br> pq essa classe na pior das solucoes poderia notificar a todos que tem um comunicacao com ela, de que a sessao foi finalizada<br> sim, e ai?<br> vc fez o q?</p><p> Phillip Calçado - All that’s sacred..comes from youth! diz:<br> basicamente o que eu fiz rpa contornar a situação foi pegar todas as threads do sistema, ver quais delas possuem sessões abertas e logar, e como isso é bem lento deve ser melhor usar um adapter nesta classe<br> mas se fosse em uma linguagem como ruby, ao criar a instancia de sessao eu poderia alterar o metodo commit() desta instancia, fazendo ele avisar a classe fabrica que foi fechada antes de chamar o metodo original </p><p>Não entendeu a solução? Em Ruby uma classe é dinâmica, você pode alterá-la em runtime. Vamos a um exemplo (você pode testá-lo <a href="http://web.archive.org/web/20090212110954/http://tryruby.hobix.com/">neste site</a>) . Então supomos que nossa classe Session seja assim:</p><p> <code><br> class Session<br> &nbsp;&nbsp;&nbsp;&nbsp;def commit<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts ‘COMMITED’<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> end<br> </code></p><p>E que quem crie sessions seja esta fabrica:</p><p><code><br> class Factory<br> &nbsp;&nbsp;&nbsp;&nbsp;def create<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Session.new<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> end<br> </code></p><p>Agora vamos modificar a fabrica para que guarde o numero de Sessions abertas e altere o método Session#commit</p><p><code><br> class Factory<br> #vamos guardar a quantidade de sessoes aqui<br> &nbsp;&nbsp;&nbsp;&nbsp;@count<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;#cria um ‘getter’ para o count<br><br> &nbsp;&nbsp;&nbsp;&nbsp;attr_reader :count<br><br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;#construtor<br> &nbsp;&nbsp;&nbsp;&nbsp;def initialize<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@count=0<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;#metodo usado para informar que uma sessao foi finalizada<br> &nbsp;&nbsp;&nbsp;&nbsp;def session_ended<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@count=@count-1<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;def create<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s=Session.new<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;#muda o metodo do objeto criado e cria variavel de instancia para localizar a factory<br> &nbsp;&nbsp;&nbsp;&nbsp;class &lt;&lt;s<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#onde vamos guardar uma referencia para nossa factory<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@factory<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#cria um ’setter’ para factory<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attr_writer :factory<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Muda o nome do metodo commit real<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alias original_commit commit<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def commit<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@factory.session_ended<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#chama o metodo antigo<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return original_commit<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;#diz à sessao modificada que esta eh sua factory<br> &nbsp;&nbsp;&nbsp;&nbsp;s.factory=self<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;@count=@count+1<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;return s<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> end<br> </code></p><p>Ficou bem maior que o método original, mas muito do que foi adicionado são getters, setters e construtores. No fim do post está o texto do teste completo, basta salvar num arquivo e rodar no interpretador ruby.</p><p>Note que o código não é thread-safe, teríamos que colocar uns monitores ali. Também é bom notar que não são todas as instâncias de Session que são afetadas mas apenas aquelas criadas pela Factory. Caso fosse necessário, poderíamos fazer com que todas as instâncias d Session fossem alteradas.</p><p>É assim que coisas como o Rails são implementadas e por isso é tão complexo criar ‘um Rails em Java’.</p><p>Se pudesse fazer isso em Java não estaria quebrando minha cabeça amanhã para otimizar uma ferramenta de diagnóstico… Minhas opções são: (a) empacotar a classe Session num Adapter ou (b) continuar buscando todas as threads e vendo se elas possuem sessões abertas</p><p>Provavelmente vou criar um adapter ou se não puder uma subclasse. <code>WrappedSession implements Session</code> e implemento o método <code>commit()</code> fazendo o necessário antes de delegar à Session real. O fato de criar uma classe nova na hierarquia apenas para adicionar um conceito ortognal (ou um cross <em>cutting concern</em>, algo importante para o sistema mas não importante do ponto de vista do usuário) não me faz muito bem. E se eu tiver que acrescentar esta funcionalidade a uma outra subclasse de Session criada por alguma das outras factories? Com wrapper tudo bem, mas se não usar subclasse eu crio outra com a mesma finalidade? E se eu quiser que todas as Sessions, não importa onde foram criadas, tenham esta funcionalidade? <em>Find “Session”/Replace with “WrapperSession”</em>?</p><p><em><s>Ps: estou tendo problemas com o WYSIWYG do WrodPress, a formatação tem ficado meio bagunçada devido a isso</s> - Com ajuda do <a href="http://web.archive.org/web/20090212110954/http://www.plentz.org/">Diego</a> isso foi meio que resolvido :P</em></p><p>Exemplo completo:<br> <code><br> class Session<br> &nbsp;&nbsp;&nbsp;&nbsp;def commit<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts 'COMMITED'<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> end<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> class Factory<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;#vamos guardar a quantidade de sessoes aqui<br> &nbsp;&nbsp;&nbsp;&nbsp;@count<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;#cria um ‘getter’ para o count<br> &nbsp;&nbsp;&nbsp;&nbsp;attr_reader :count<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;#construtor<br> &nbsp;&nbsp;&nbsp;&nbsp;def initialize<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@count=0<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> <br> #metodo usado para informar que uma sessao foi finalizada<br> def session_ended<br> &nbsp;&nbsp;&nbsp;&nbsp;@count=@count-1<br> end<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;def create<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s=Session.new<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#muda o metodo dentro do objeto criado e cria variavel de instancia para localizar a factory<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class &lt;&lt;s<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#onde vamos guardar uma referencia para nossa factory<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@factory<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#cria um ’setter’ para factory<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attr_writer :factory<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Muda o nome do metodo commit real<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alias original_commit commit<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def commit<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@factory.session_ended<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#chama o metodo antigo<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return original_commit&nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;#diz à sessao modificada que esta eh sua factory<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;s.factory=self<br> &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@count=@count+1<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return s<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> end<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> f = Factory.new<br> s = f.create<br> puts f.count<br> s.commit<br> puts f.count<br> </code></p><p><strong>UPDATE:</strong> O taq deu uma limpada no código, ficou menor mas se for sua primeira vez vendo algo em Ruby pode ser mais confuso::<br> <code><br> class Session<br> &nbsp;&nbsp;&nbsp;&nbsp;def commit<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts "COMMITED"<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> end</code></p><p>class Factory<br> &nbsp;&nbsp;&nbsp;&nbsp;attr_reader :count # pode usar o attr_reader direto que ele cria a @count<br> &nbsp;&nbsp;&nbsp;&nbsp;def initialize<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@count = 0 # aqui tem que 'setar' o valor default né, inclusive se você não<br> &nbsp;&nbsp;&nbsp;&nbsp;end # tivesse usado o attr_reader, a @count poderia ser criada aqui sem problemas<br> &nbsp;&nbsp;&nbsp;&nbsp;def session_ended<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@count -= 1 # olha o -= ao invés do @count = @count - 1<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> &nbsp;&nbsp;&nbsp;&nbsp;def create<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = Session.new<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class &lt;&lt; s<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attr_writer :factory # mesmo esquema acima - não precisa explicitar @factory<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alias original_commit commit<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def commit<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@factory.session_ended<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;original_commit<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.factory = self<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@count += 1 # olha o += ao invés do @count = @count + 1<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s # não precisa do return, apesar de ficar mais legível com ele<br> &nbsp;&nbsp;&nbsp;&nbsp;end<br> end</p><p><code>f = Factory.new<br> s = f.create<br> puts f.count<br> s.commit<br> puts f.count<br> </code></p></body></html>