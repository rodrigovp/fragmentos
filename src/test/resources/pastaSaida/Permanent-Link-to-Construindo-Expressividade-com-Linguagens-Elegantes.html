<html><head><title>Permanent Link to Construindo Expressividade com Linguagens Elegantes</title><meta charset="utf-8"></head><body><h2>Permanent Link to Construindo Expressividade com Linguagens Elegantes</h2><p>Ainda não vi uma definição sobre o que seria uma linguagem elegante, então lá vai a minha:</p><p> Uma linguagem elegante é baseada em primitivas simples e extensíveis e, principalmente, sem muitas exceções. </p><p>Segundo esta definição Ruby, Smalltalk e LISP são elegantes. Java é um pouco, C# com suas centenas de exceções (sobrecarregar + é diferente de sobrecarregar [], dentre outras várias exceções) não é.</p><p>Uma linguagem elegante é simples e compacta. <a href="http://web.archive.org/web/20090106070144/http://guj.com.br/posts/list/65469.java">É de se esperar que não tenha sobrecarga de operadores</a>, mas <strong>isso não é verdade</strong>. O problema das pessoas com sobrecarga de operadores é porque elas vêem isso como uma quebra da <em><a href="http://web.archive.org/web/20090106070144/http://www.faqs.org/docs/artu/ch11s01.html">rule of least surprise</a></em>. Essa regra diz (implora, eu diria) para não surpreendermos nossos usuários modificando o mundo que eles já conhecem para que uma ação traga consequências não esperadas. Por exemplo imagine que você vai modificar um programa como o <a href="http://web.archive.org/web/20090106070144/http://www.computerhope.com/unix/uls.htm">ls</a> para dar mais performance (uau, você é bom!). Faça o que quiser mas não mude os parâmetros de entrada e saída ou você vai quebrar um zilhão de programas e scripts pelo mundo todo. Caso introduza uma feature nova faça o usuário explicitamente solicitar por ela (passando um flag no estilo <em>ls -lira –my-fancy-new-feature</em>) e mantenha o default como o antigo.</p><p>E onde entra sobrecarga de operadores nisso? Lá no seu primeiro curso de programação (ou no seu primeiro livro se você opta pelo caminho mais difícil) deve ter aprendido sobre literais, variáveis, condicionais e… operadores. Operadores são caracteres especiais com uma função bem definida na linguagem, por exemplo o operador de divisão, de resto, de adição…</p><p>Em Java, quando você chama:<br> <code><br> String texto = "abc".toUpperCase();<br> </code></p><p>É fundamentalmente diferente de quando chama:</p><p><code><br> int numero = 12 + 24;<br> </code></p><p>Porque um método e um operador <strong>são coisas diferentes</strong> e você aprendeu a pensar desta forma. Se amanhã eu puder sobrescrever o operador + para que escreva algo na tela você vai se surpreender porque não era isso que o manual da linguagem te disse.</p><p>Ainda assim, existem muitas ocasiões onde sobrecarga de operador são mais que convenientes, são semânticos. Imagine o exemplo do nosso BigDecimal:</p><p><code><br> BigDecimal a = new BigDecimal("100");<br> BigDecimal b = new BigDecimal("300");<br> </code></p><p>Some os dois. Ok, você é um programador Java esperto e sabe que vai ter que fazer algo como:</p><p><code><br> BigDecimal resultado = a.add(b);<br> </code></p><p>Mas disso até me dizer que é melhor que usar ‘+’ é outra história.</p><p>Mas e a simplicidade? Não é legal termos um conjunto pequeno de operadores que faz coisas previsíveis e que servem na maioria das vezes? <strong>Sim, é!</strong> Mas num mundo onde tudo migra para mais expressividade, com Model-Driven Development e Domain-Specific Languages ter este tipo de limitação não é interessante. <strong>As melhores linguagens para construir DSLs são as mais flexíveis e por acaso as mais elegantes</strong>, que coincidência, não? E como Ruby, que se enquadra nestes dois aspectos, lida com isso?</p><p>Simples. Em Ruby não existem operadores, pelo menos não como você está acostumado em Java, operadores são apenas apelidos para métodos. A vantagem disso é que se muda o modelo mental, a partir do momento que você sabe que um operador e um método são a mesma coisa você tem com operadores o mesmo cuidado que tem com métodos. Ao chamar add() do BigDecimal você tem que saber se o método vai retornar o resultado como um objeto separado, se vai modificar os objetos passados como parâmetros, etc. Como você faz isso? Lendo a documentação até se familiarizar com a classe e seu idioma. Após familiarizado você começa a usar sem pensar.</p><p>E quando você espera estar lidando com uma classe que sobrescreve um operador e na verdade recebe como parâmetro uma subclasse dela? Sem problemas! Se o autor seguiu os princípios básicos da Orientação a Objetos, que derivam do <a href="http://web.archive.org/web/20090106070144/http://fragmental.com.br/wiki/index.php/Contratos_Nulos">Design by Contract</a> e o <a href="http://web.archive.org/web/20090106070144/http://en.wikipedia.org/wiki/Liskov_substitution_principle">Princípio de Substituição de Liskov</a> a subclasse tem que obedecer o contrato da classe-pai, e se você obedeceu os mesmos princípios não precisa de nada que não esteja no contrato.</p><p>Esse tipo de resistência com funcionalidades é o tipo de coisa que se elimina aprendendo várias linguagens e estudando suas motivações. Existem algumas linguagens como as citadas que merecem ser estudas ainda que você nunca as vá utilizar de fato. Elas abrem a sua cabeça.</p></body></html>