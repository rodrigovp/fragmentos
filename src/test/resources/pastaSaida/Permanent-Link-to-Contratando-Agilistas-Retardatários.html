<html><head><title>Permanent Link to Contratando Agilistas Retardatários</title><meta charset="utf-8"></head><body><h2>Permanent Link to Contratando Agilistas Retardatários</h2><p>Eu bato nesta tecla frequentemente, mas nunca deixo de ficar espantado em como as pessoas conseguem fazer a associação completamente errada ao tentar adequar a posição de desenvolvedor de software em algum lugar. Existe uma pressão social para que enquadremos esta profissão em algum critério, preferencialmente apenas estendendo uma já existente. Eu não tenho nada contra a princípio, na verdade deixo sempre bem claro que na minha visão desenvolvimento de software é uma engenharia, uma ciência destinada a resolver problemas.</p><p>Eis que aí mora o perigo. Ao associar a profissão com engenharia logo se vê gente que tenta adequar <strong>tudo</strong> a esta área, como se houvesse apenas uma maneira de fazer engenharia. O maior problema, entretanto, é que o desenvolvimento de uma solução em software é diferente do da maioria das engenharias (talvez não da química… preciso pesquisar sobre isso). Numa engenharia tradicional (civil,agrónoma, sanitária…) geralmente você precisa entregar um projeto que vai ser executado por outros profissionais, quase sempre profissionais que não possuem o grau de engenheiro, ou seja: não saberiam resolver os problemas por si só. A implementação do projeto tem que seguir o plano minuciosamente, primeiro porque a mão-de-obra teoricamente não possui conhecimento suficiente para tomar decisão em caso de dúvida e em segundo lugar porque um projeto deste geralmente é algo big bang. Você não consegue construir meia ponte, deixar uns carros passarem por uma semana e ajustar o projeto. precisa construir a ponte toda, do início ao fim, de uma só vez e seja lá o que Zahl quiser.</p><p>Bem, detesto ser estraga-prazeres de tantos mas <strong>não é assim que software funciona</strong>. Há muito tempo que descobriram que a melhor maneira de produzir software é de maneira <strong>iterativa e incremental</strong>. Este é o princípio básico de RUP, Scrum e XP, só para citar algumas metodologias/processos de desenvolvimento. Nestes processos sabe-se muito bem que o nível de acerto em um projeto BDUF, que segue o modelo dos engenheiros do parágrafo anterior, é passo certo para o fracasso. Ok, mentira minha, certo não é. Eu conheço <strong>algumas poucas</strong> empresas, de <strong>ramos muito específicos</strong> (geralmente gente que lida com regulamentação governamental pesada) que consegue levar este modelo. Aliás, sabe qual é esse modelo onde você produz uma especificação antes e escreve código depois? <strong>Waterfall</strong>, ou Cascata.</p><p>Eu me lembro em algum momento de 2002 tendo uma aula na faculdade sobre este modelo. O professor, uma pessoa com curriculum bem razoável e instrutor certificado IBM para RUP, ou algo assim, desenhou o velho diagrama espiralado no quadro e escreveu embaixo uma lista copiada da apostila sobre vantagens e desvantagens dos dois modelos. Em seguida ele começaria a descrever o modelo iterativo incremental desta maneira:</p><p> Primeiro, é feita a análise do problema. A análise é, certamente, a parte mais importante de todo o processo. Neste momento são identificados os problemas, os atores, os casos de uso e tudo mais que é necessário para chegarmos na próxima etapa, o projeto do sistemas.</p><p>Na fase de projeto os projetistas pegam o trabalho do analista -que deve ser completo o suficiente para que o projetista faça seu trabalho sem ter que esclarecer qualquer dúvida- e criam o modelo da solução para aquele problema, criando diagramas de interação entre as classes e seus estados.</p><p>Logo em seguida os codificadores pegam este projeto e escrevem software. O sistema assim está entregue. Notem que um sistema feito desta forma divide corretamente as responsabilidades e gera código de qualidade e bem documentado. <a href="http://web.archive.org/web/20090106070144/http://blog.improveit.com.br/articles/2007/07/12/improvecast-8-entrevista-com-carlos-barbieri-sobre-o-mps-br">Nenhum programador ninja sai escrevendo código por aí</a> sem que antes tudo seja validado pelo analista, projetista e arquiteto do sistema. </p><p>Naquela época eu sentia que havia algo errado mas não sabia dizer o que era. Apesar dele não ter explicado direito o tal espiral se isso era diferente do waterfall esta descrição não fazia sentido. <strong>Ele descreveu o processo de waterfall</strong>, com uma única peculiaridade de atribuir papéis aos participantes. <strong>Ele estava errado</strong>, não tinha entendido nem mesmo o que era modelo iterativo incremental, muito menos o RUP no qual se certificara.</p><p>Quem olha o gráfico das baleias corcundas pode realmente ter uma impressão desta, mas eu realmente espero que alguém que seja um instrutor certificado, ou mesmo um instrutor não certificado, saiba que mais importante que a figura é o embasamento literário. Os livros sobre o tema vão te explicar o que aquelas curvas significam e, ao contrário do senso comum, <strong>elas não significam fases no seu projeto</strong>. Ok, nova mentira, elas significam sim, até são chamadas de <em>phase</em>, mas o meu ponto é que este conceito não é o mesmo que você vai ouvir por aí.</p><p>Uma fase no RUP indica apenas um período de tempo com uma dada característica mais marcante. Na fase de Inception, por exemplo, a atividade mais marcante é a de modelar o negócio e trabalhar requisitos. <strong>Isso não significa que você não vai coletar e analisar requisitos mais tarde</strong> pelo contrário. indica apenas que a maior parte do trabalho naquele tempo é destinada a esta atividade. E por quê? Porque precisamos de modelos de análise completos? <strong>Não!</strong> Simplesmente porque naquela altura do campeonato não sabemos direito o que vamosconstruir e estamos tentando entender mais ou menos para começarmos a trabalhar.</p><p>Em RUP geralmente as funcionalidades com maior risco ou impacto arquitetural serão implementadas primeiro, XP e Scrum possuem uma estratégia que eu considero muito mais inteligente neste aspecto que é trabalhar logo de cara pequenos pedaços que o cliente escolher. No fim das contas o efeito é bem semelhante: começamos a trabalhar no sistema pedaço por pedaço, descobrimos os pontos que precisam ser ajustados, os ajustamos e seguimos em frente: <strong> o desenvolvimento iterativo é completamente baseado feedback que uma iteração dá para a equipe</strong>. XP e Scrum possuem diversas características mais interessantes que as implementações comuns de RUP para boa parte das pessoas (iterações curtas, planning game, reuniões super-ultra-rápidas diárias…) mas eu diria que estão ganhando <strong>tanto</strong> terreno e tão rápido pelas falhas nas pseudo-implementações de RUP que os instrutores certificados, appraisers CMM/CMMi/MPS.BR/Sigla-de-3+x-letrinhas-que-estiver-na-moda-este-mês e demais membros da fauna de processos de desenvolvimento de software insistem em aplicar. Após alguns anos se enganando o mercado começa a acordar e procura um novo salvador da pátria, nesta armadilha está caindo um conceito que é, na minha opinião, uma evolução pura e simples dos processos existentes (mais foco nas pessoas -em vez de temer o ‘programador ninja’ fazer com que o conhecimento se espalhe por todos- e em resultados palpáveis e obtidos rapidamente, por exemplo), processos estes que nunca foram implantados de fato na maioria das empresas, destas que compraram uma caixinha de pseudo-RUP e ganharam um belo waterfall com zilhões de documentos para preencher todo dia.</p><p>E o meu maior medo agora é de estar vendo isso acontecer com processos ágeis. Durante o excelente curso de Certified Scrum Master (onde a certificação é algo <strong>simbólico</strong>, não quer dizer nada além de que você teve x horas de treinamento, por isso pode tirar da sua assinatura de e-mail, por favor?) ministrado pela <a href="http://web.archive.org/web/20090106070144/http://www.teamware.com.br/">Teamware</a> lá no Rio conversamos muito sobre isso no cocktail. Já se pode ver empresas muito conhecidas da comunidade por prometer mundos e fundos, entregar (quando entrega) software de péssima qualidade e aos olhos da cara que de repente viu no Scrum, por exemplo, vantagem competitiva.</p><p>Como nós vamos conseguir saber se estas pessoas entenderam o mínimo necessário? Não vamos. Apenas podemos nos preparar para que quando estas figurinhas aparecerem com seus Certified Scrum Master, Certified Rational QualquerCoisa, PMP, CMMi, MPS.BR e tudo mais que couber no cartão de visitas nós possamos fazer uma avaliação real, sem nos basearmos nas baboseiras que sempre são citadas.</p><p>Fazer este tipo de avaliação não é difícil. Se você não entende a vantagem competitiva e está apenas curioso pergunte ao fornecedor o que ele te oferece de diferente. Ouça bem o que ele lhe diz, estude. Caso não saiba avaliar contrate um consultor e peça referências em um fórum como o do <a href="http://web.archive.org/web/20090106070144/http://www.guj.com.br/">GUJ</a> (onde temos o maior prazer em rechaçar fornecedores ruins em geral). Peça para fazer uma visita ao ambiente de trabalho, qualquer menção da palavra ‘fábrica’ já é sinal de eliminação do processo seletivo: fábricas são um modelo que não funciona para software (pense numa fábrica de notícias num jornal. Funcionaria? É o mesmo princípio: atividade criativa não se serializa ou controla desta forma) e <strong>são o extremo oposto</strong> de metodologias ágeis (não necessariamente do RUP, mas mesmo assim a empresa deve perder muitos pontos na avaliação). A empresa tem um portfólio no site, todas têm, então ligue para os clientes anteriores. De surpresa, claro, não avise ao fornecedor ou ele irá te indicar apenas referências que ele sabe o que dirão.</p><p>Dá trabalho, mas é melhor gastar um mês fazendo a seleção de um fornecedor decente do que ficar anos e anos se lamentando de um projeto furado.</p></body></html>