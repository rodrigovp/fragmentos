<html><head><title>Permanent Link to Gerenciando Débitos</title><meta charset="utf-8"></head><body><h2>Permanent Link to Gerenciando Débitos</h2><p>Todo projeto que já participei, dos meus pet-projects até os com equipes imensas, possuem algum nível de <a href="http://web.archive.org/web/20090211221158/http://c2.com/cgi/wiki?TechnicalDebt">tech debt</a>. Sempre a mesma história: <em>não temos tempo para isso agora, na próxima oportunidade corrigimos</em>.</p><p>O problema é que em muitos casos o acúmulo de coisas que deixamos pelo meio do caminho é prejudicial à saúde do projeto. Mais que preciosismo de nerds e perfeccionistas, tech debt pode –e geralmente vai- atrasar o andamento do time.</p><p>Nos projetos que eu gerencio eu gosto de alocar um orçamento para resolver estes problemas. Durante o <a href="http://web.archive.org/web/20090211221158/http://www.extremeprogramming.org/rules/planninggame.html">planning game</a> eu deixo claro que precisamos resolver problemas enquanto estamos implementando funcionalidades e geralmente aloco alguns pontos na iteração para eles, normalmente algo perto de 20% do trabalho. Normalmente eu aceito que estas <a href="http://web.archive.org/web/20090211221158/http://www.extremeprogramming.org/rules/userstories.html">histórias</a> técnicas tenham prioridade baixa e no geral tudo ocorre bem.</p><p>Se temos uma emergência então eu costumo não ser muito flexível em relação à solução do problema. As histórias técnicas neste caso ganham prioridade máxima dentro da iteração.</p><p>Como geralmente o cliente está satisfeito com a velocidade da equipe num processo ágil (se não está temos outro problema) quando sobra –e quase sempre sobra- tempo extra numa iteração geralmente eu preencho com tech debt, e em especial deixo os desenvolvedores priorizarem o que querem fazer. Muitas vezes não dá tempo para fazer homologação destas mudanças durante a iteração vigente e elas acabam indo para produção apenas na iteração posterior, mas é uma boa estratégia.</p><p>O que importa é não deixar o tech debt acumular. Se você tem duvidas dos problemas que o acúmulo de histórias técnicas causam basta lembrar a última vez que você entrou em um projeto para dar manutenção em um sistema pré-existente. Eu <strong>nunca</strong> vi um caso onde o sistema antigo não tenha toneladas de problemas causados por “deixar para depois” mudanças que não eram urgentes mas foram crescendo em urgência com o tempo.</p><p>E claro que meu projeto atual não é diferente. Trata-se da conversão de boa parte de um sistema legado em Java para Ruby (não Rails, Ruby). Como todo projeto deste tipo o orçamento não contempla uma reescrita do sistema, apenas uma conversão. Isso quer dizer que se um módulo assovia e chupa cana em Java ele, teoricamente, vai assoviar e chupar cana em Ruby.</p><p>O bom de trabalhar em um time ágil é que não é porque no início do projeto não se pensou em melhorar as coisas que isso precisa ser verdade até o fim dele. Após a equipe (desenvolvedores, <a href="http://web.archive.org/web/20090211221158/http://blog.fragmental.com.br/2008/01/15/quando-eu-crescer-quero-ser-analista-de-sistemas/">analistas de negócios</a> e gerente de projetos) percebemos que alguns itens realmente estavam atrapalhando o andamento do projeto. Nossos dias estão cercados de tarefas repetitivas que existem apenas para contornar alguma “gambiarra” que o sistema original tinha e nós estamos reproduzindo de maneira burra. Levamos a questão aos clientes e fizemos entender que se gastarmos alguns pontos nestas tarefas em algumas iterações nossa velocidade irá aumentar, e muito.</p><p>Apos conseguirmos 25% dos pontos de uma iteração para histórias técnicas veio a questão: temos dezenas de problemas, o que faremos primeiro? Como é um time grande cada um tem seu ponto de vista sobre o que está errado e o que precisa melhorar, então fizemos da maneira ágil: disciplina e flexibilidade.</p><p>Marcamos uma reunião com o time e coletamos em cartões todos os problemas que conseguíssemos pensar. Os cartões foram pregados na parede, divididos entre coisas do dia-a-dia e coisas que realmente indicam a visão que o sistema deve tomar, aspectos arquiteturais.</p><p><a href="http://web.archive.org/web/20090211221158/http://www.flickr.com/photos/pcalcado/2268593796/" title="14022008446.jpg by pcalcado, on Flickr"><img src="http://web.archive.org/web/20090211221158im_/http://farm3.static.flickr.com/2310/2268593796_b95c6745b4_m.jpg" width="240" height="180" alt="14022008446.jpg"></a></p><p>Depois cada um recebeu 5 votos para distribuir entre os cartões. Quase todas as histórias eram importantes então precisamos limitar o numero de votos para entender o que realmente é critico.</p><p><a href="http://web.archive.org/web/20090211221158/http://www.flickr.com/photos/pcalcado/2268593640/" title="14022008445.jpg by pcalcado, on Flickr"><img src="http://web.archive.org/web/20090211221158im_/http://farm3.static.flickr.com/2002/2268593640_b13e367c2e_m.jpg" width="240" height="180" alt="14022008445.jpg"></a></p><p>Apos este exercício nós criamos um backlog paralelo para o produto, apenas com histórias técnicas. Este backlog foi estimado e baseado nele o time decide que história técnica entra nos 25% de pontos disponíveis.</p><p><a href="http://web.archive.org/web/20090211221158/http://www.flickr.com/photos/pcalcado/2268593480/" title="13022008442.jpg by pcalcado, on Flickr"><img src="http://web.archive.org/web/20090211221158im_/http://farm3.static.flickr.com/2050/2268593480_68100bfa7c_m.jpg" width="240" height="180" alt="13022008442.jpg"></a></p><p>Uma das vantagens dessa abordagem já foi percebida. Nosso sistema é um fluxo de operações em sequência. Operações em sequência são uma ótima área para programação procedural e isso fez com que os desenvolvedores originais do sistema seguissem este paradigma.</p><p>Claro que quando se mistura uma linguagem orientada a Objetos com código procedural é necessária muita cautela, e a maioria das pessoas acha que para o código ser procedural basta usar atributos públicos nas suas classes. Existem muitas métricas para qualidade de código procedural (a maioria das métricas de código OO são evoluções ou adaptações destas, na verdade) e nosso código não seguia nenhuma.</p><p>Aproveitando o nosso orçamento para histórias técnicas nós introduzimos um sistemas de jobs, uma implementação do padrão <a href="http://web.archive.org/web/20090211221158/http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">Chain of Responsibility</a>. Até agora 50% das funções já foram convertidas para o modelo novo e a cada iteração mais são convertidas.</p><p>O resultado das ultimas iterações mostra um aumento consistente de 10% na velocidade. Todos os envolvido creditam esta melhoria à mudança e ainda estimamos que quando todo o sistema for convertido para a nova arquitetura teremos por volta de 25% de aumento total.</p><p>Existem coisas simples que podem decidir se um projeto vai ser um sucesso ou fracasso. Não esconder sujeira debaixo do tapete é uma delas.</p></body></html>