<html><head><title>Permanent Link to A Linha Tênue entre o Hackin’ e a Gambiarra</title><meta charset="utf-8"></head><body><h2>Permanent Link to A Linha Tênue entre o Hackin’ e a Gambiarra</h2><p>Dia desses estava programando em par com um amigo quando encontramos um problema. Estávamos utilizando o excelente <a href="http://web.archive.org/web/20090212105947/http://xstream.codehaus.org/">XStream</a> para transformar um <a href="http://web.archive.org/web/20090212105947/http://fragmental.com.br/wiki/index.php?title=Desenvolvendo_Sistemas_OO_Com_Padr%C3%B5es_de_Neg%C3%B3cio">domain model</a> em algo que pudesse ser consumido via webservices de arquitetura REST quando percebemos que nossos XMLs iam ficar enormes e com uns 40% de informações repetidas. Simplesmente haviam dados que eram comuns a várias entidades sendo serializadas em uma lista e se repetíssemos os dados para cada entidade serializada teríamos um grande problema.</p><p>Conversando com o <a href="http://web.archive.org/web/20090212105947/http://www.guj.com.br/user/profile/12.java">Guilherme</a>, ficamos sabendo que o <a href="http://web.archive.org/web/20090212105947/http://xstream.codehaus.org/graphs.html">XStream possibilita o uso de referências</a>. Infelizmente também descobrimos que isso só funciona se você tem várias referências para o mesmo objeto (ou seja: tem que ser <code>==</code>, não basta ser <code>equals()</code>). Seguindo indicações do Guilherme, vimos que para alterar este comportamento deveríamos mexer em uma classe específica que, a princípio, poderia ser estendida por uma subclasse nossa.</p><p>Aí a falta que faz seguir o <a href="http://web.archive.org/web/20090212105947/http://www.google.com/url?sa=t&amp;ct=res&amp;cd=2&amp;url=http%3A%2F%2Fwww.objectmentor.com%2Fresources%2Farticles%2Focp.pdf&amp;ei=Bn4QRu6LJZ2YgwSPws2eAw&amp;usg=__2roa6LuJwUaEkpNJE_Fdu9XUE2Q=&amp;sig2=F9XBe6i57O2hZ9692OHoag">Open-Closed Principle</a> (OCP. E não, não é a <a href="http://web.archive.org/web/20090212105947/http://en.wikipedia.org/wiki/Omni_Consumer_Products" ocp do robocop< a>) se faz cruel. O OCP foi difundido por Bertrand Meyer, um dos papas da OOP, e diz:</a></p><p> Um módulo (uma classe, por exemplo) deve ter uma interface rígida e encapsulada para uso por outros módulos e ao mesmo tempo ser aberta e flexível apra ser estendida por estes. </p><p>Basicamente isso te dá uma diretiz para que crie métodos bem-definidos, não deixando vazar muita informação sobre o que sua classe faz mas ao mesmo tempo faça com que se alguém tiver que estender esta classe isso seja um processo sem dor. Se você não está interessado em deixar que outras pessoas estendam sua classe marque-a como <code>final</code> e acabe com o mal pela raiz.</p><p>Bom, ainda que seja uma biblioteca (não, não é uma API!) fantástica, o XStream peca neste quesito. A classe que faz esta comparação é inserida dentro de outra como atributo <code>private</code> e sem setter <code>public</code> ou <code>protected</code>. A primeira tentativa foi utilizar reflection para injetar os atributos ‘na marra’, a reflection em si funcionou mas… descobrimos que tratava-se de uma classe estática definida dentro de outra. Depois de ler algumas dezenas de linhas de código e escrever outras desistimos.</p><p>Percebemos um problema porque a quantidade de código que necessitávamos para adaptar o módulo foi crescendo muito. Eram várias horas de desenvolvimento e ainda não tínhamos uma solução aceitável, mas a base de código só crescia. Todos aquele código tomou tempo para ser criado (utilizando TDD) e demandaria ainda mais tempo para ser mantido no decorrer do projeto.<br> Simplesmente estávamos horas envoltos em código que não tinha nada a ver com a aplicação que estávamos desenvolvendo, nossa missão não era criar um serializador de XML mais flexível e sim transformar meia dúzia de objetos em XML utilizando uma ferramenta de mercado.</p><p>Daí, para a infelicidade de nossos egos de programadores, decidimos partir para uma solução simples (manter uma lista no contexto de marshalling do que já havia sido serializado e modificar nossos adapters) que atendia nossas necessidades. Não era tão <em>cool</em>, não usava recursos obscuros da linguagem… mas nos permitiu voltar a fazer o que somos pagos para fazer: aplicações.</p><p>Todo programador gosta de hackear uma biblioteca, um subsistema ou qualquer coisa que tenha sido feita por terceiros. Aliás, eu diria que bons programadores obrigatoriamente gostam disso. O problema é que existe um ponto em que a brincadeira deixa de ser produtiva e passa a ser mera masturbação tecnológica.</p></body></html>