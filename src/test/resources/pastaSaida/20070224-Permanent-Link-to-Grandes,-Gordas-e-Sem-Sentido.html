<html><head><title>Permanent Link to Grandes, Gordas e Sem Sentido</title><meta charset="utf-8"></head><body><h2>Permanent Link to Grandes, Gordas e Sem Sentido</h2><p>Este <a href="http://web.archive.org/web/20090211221142/http://www.infoq.com/news/2007/02/DDD-Money">estudo de caso</a> sobre <a href="http://web.archive.org/web/20090211221142/http://www.domainlanguage.com/ddd/index.html">Domain-Driven Design </a> é bem interessante. Mais do que a forma como simplificaram o código e deram sentido a ele, ele mostra um problema que já vi em muitos projetos que se dizem Orientados a Objetos. É muito comum nestes cenários termos classes gordas cheias de tipos primitivos (Strings, int, long, double, etc.), especialmente seguindo o odioso “padrão” <a href="http://web.archive.org/web/20090211221142/http://fragmental.com.br/wiki/index.php?title=Evitando_VOs_e_BOs">BO/VO</a>. </p><p></p><p>É o caso clássico de exercício de faculdade onde um problema é apresentado no estilo “uma fazenda tem 232,23 galinhas, cada uma põe 30,343 ovos/mês. Faça um programa que gere a projeção de ovos durante dez anos”. Problema ridículo de se resolver mas onde o domínio não importa. O que é 0,23 de uma galinha? O que é 0,343 de um ovo? Nenhuma galinha morre ou é comprada em 10 anos? </p><p>Para um exercício não importa. Provavelmente o seu professor está querendo que você aprenda a processar uma operação matemática utilizando um programa, não construir um sistema de gerência de galinheiro (apesar de eu conhecer histórias sórdidas nesta linha, outro dia eu conto). O domínio é apenas uma ilustração, o que importa é a manipulação de números.</p><p>Bem, acontece que aqui fora dos muros da faculdade não é bem assim. Um sistema de informação não serve para mostrar o quanto seus algoritmos são performáticos, que você leu toda a série do Knuth ou como eles podem ser aplicados em trinta mil situações diferentes. Sistemas servem para resolver problemas das pessoas e sua estrutura interna deve mostrar isso.</p><p>Um bom design vai mapear os conceitos do negócio de maneira transparente para o software. Uma das grandes vantagens desta prática é quando você entra em uma reunião, um planning game ou algo do tipo e desenvolvedores e cliente falam a mesma língua. Funciona mais ou menos assim:</p><p>Quando você tem classes gordas e vazias em significado, quando o cliente fala algo, pede uma mudança, etc. ele fala em termos de negócio. Enquanto ele vai falando seus engenheiros tentam transformar mentalmente aqueles conceitos nas suas representações. Quando o cliente fala ‘Venda’ o programador imediatamente tenta adivinhar quais das 10 classes diferentes que lidam com este conceito (vários BOs, VOs e tudo de ruim que alguém possa criar) é responsável por aquela parte do conceito de venda. Quando ele enfim descobre e pensa em algo que pode solucionar o problema ele precisa fazer o caminho inverso, mapeando sua solução completamente técnica em uma classe que não faz o menos sentido para o cliente para <em>suitspeak</em>.</p><p>Agora imagine que o software modela o negócio corretamente. Imagina que ao invés de uma grande classe cheia de tipos primitivos nós temos várias classes que tentam chegar próximas de um mapeamento 1-1 com o negócio. O conceito de venda é representado por uma classe venda que possui todas as características desta (lógica e dados), se relacionando com outras classes que também modelam o negócio. Por exemplo ela possui 1 ou mais instâncias da classe prestação, que possuem os dados das parcelas das compras (data de vencimento, valor, data de pagamento, se está vencida, quantos dias do vencimento, multa a ser aplicada, etc.). Quando o cliente fala o desenvolvedor imediatamente sabe do que ele está falando. Sem mapeamentos adicionais, quando o conceito de venda mudar o desenvolvedor sabe que deve mudar a classe venda.</p><p>Essa é a <em>ubiquitous language </em>que Eric Evans tanto dá ênfase, a linguagem onipresente que deve existir entre desenvolvedores e clientes. O uso desta linguagem permite chegar ao ponto onde o cliente está apto a questionar as classes de negóciod e maneira eficiente. Se as classes mapeiam profundamente o modelo dele, não devem existir conceitos diferentes dos que ele conhece nelas. Claro que notações como UML podem dificultar a comunicação mas se a equipe modelar de maneira ágil e apenas o necessário a barreira da notação técnica é facilmente transpassável.</p><p>Eu trabalhei em um sistema de gestão de laudos clínicos há muitos anos. Para projetar o sistema eu não tive dúvidas: a interface de entrada eram formulários e a saída era composta por relatórios que eram os tais laudos. Tudo muito simples: havia um objeto ‘laudo’ que continha algumas informações do paciente, as informações do exame, diagnóstico e etc. O sistema seriviria tanto para laudos médicos quanto para qualquer outro tipo de relatório, e era tão simples que eu cogitei fazer em Microsoft Access.</p><p>O problema começou quando houveram algumas mudanças sutis no modelo de negócios. Um tipo de relatório passou a requerer tratamento especial. Depois outro. E outro. </p><p>Neste instante crio uma <em>rule of thumb</em> em programação: <em>você pode medir o quanto um código é ruim pela quantidade de ifs necessárias para implementar uma mudança.</em> Neste caso basta dizer que minhas teclas ‘i’ e ‘f’ estavam gastas.</p><p>Como sempre o problema é do cliente que não sabe especificar direito blablablabla, fui reclamar com ele. Aquilo não podia continuar, como pode mudar tanta coisa ao mesmo tempo, o sistema emite laudos, não é o Microsoft Word. Nesta conversa eu percebi a grande besteira que tinha feito.</p><p>Eu não modelei o domínio do cliente, eu modelei um sistema de laudos genérico. Acotnece que para o cliente existiam X tipos de laudos, cada um com informações muito específicas e que seguiam por um fluxo de negócios diferente. A versão original do sistema cobriu todas as necessidades de todos os laudos como se eles fossem um só tipo, um super-laudo. Quando cada um mudou para um lado eu tive que esticar o super-laudo até arrebentar.</p><p>O cliente não queria um super-laudo. Ele me falou desde o momento 0 que queria gerenciar os laudos que emite, me disse quais eram e as necessidades de cada um. Um dia, ainda durante a análise, eu peguei um bando de diagramas para tentar validar o que eu tinha entendido. Foi uma experiência extremamente frustrante, o cliente não entendia nada daquilo que ele havia modelado junto comigo. Pensei logo nos professores de facudlade dizendo que o maior problema é sempre que o cliente não sabe o que quer e ignorei.</p><p>Quando chegou ao fundo do poço, após a reunião onde eu fui sabiamente descascado, tive que tomar uma atitude. Me tranquei num quarto (eu era <a href="http://web.archive.org/web/20090211221142/http://www.fragmental.com.br/wiki/index.php?title=Guia_de_Guerra_Para_Freelancers">freelancer</a> nesta época) e só sai depois que modelei o sistema de acordo com o que as pessoas pensavam. Funcionou, ganhei flexibilidade e melhorei o diálogo, mas esta reescrita saiu do meu bolso, o cliente não pagou para consertar a besteira que eu fiz.</p><p>Isso leva a outro ponto que eu sempre repito: <em>o cliente não quer saber se é java, C++, se é OO, se o código fede, métricas nem nada, ele quer que o treco funcione. Ok, mas ele também não vai querer saber se você tem que alterar 30 arquivos porque seu projeto é uma porcaria, ele quer que você altere, e rápido.</em></p></body></html>