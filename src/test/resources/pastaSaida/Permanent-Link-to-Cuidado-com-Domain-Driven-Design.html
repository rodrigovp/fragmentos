<html><head><title>Permanent Link to Cuidado com Domain-Driven Design</title><meta charset="utf-8"></head><body><h2>Permanent Link to Cuidado com Domain-Driven Design</h2><p>Em tecnologia existe um fenômeno interessante. Existe um problema qualquer. Alguém resolve o problema de um modo e as pessoas começam a usar este modo. O detalhe é que as pessoas não param para ler as fundamentações técnicas, a coisa vira um grande grupo de achismo. Aí surge outra solução que é mais eficiente e utilizada por uns poucos que tentam convencer os outros. Quando finalmente as pessoas se convencem elas repetem o ciclo, não estudando a fundo as bases e caindo no conto do vigário.</p><p><a href="http://web.archive.org/web/20090212110155/http://guj.com.br/posts/list/30/62818.java">Este post no GUJ</a> mostra um claro desvio dos padrões estipulados por Domain-Driven Design. Vamos desmistificar a coisa: DDD é uma forma disciplinada de criar um <a href="">Domain Model</a>, só isso. O foco da técnica é criar um domínio que “fale a língua” do usuário. Isso não quer dizer que você vá “mapear o mundo real” com objetos, esse não é o objetivo nem da técnica <a href="http://web.archive.org/web/20090212110155/http://blog.fragmental.com.br/2007/06/16/objetando/">nem de Orientação a Objetos</a> em primeiro lugar.</p><p>Passeando pela thread, você pode perceber diversas coisas fora do que é definido em DDD. Os conceitos de Domínio e Contexto confusos. Domínio é o que o programa (seja um exercício de faculdade ou um sistema empresarial) modela, o que ele se propõe a resolver. O modelo que você criou deste domínio (o Domain Model) certamente possui intersecções com modelos criados em outros sistemas, serviços, etc. Neste caso o dividimos em Contextos:</p><p>Explicitly define the context within which a model applies. Explicitly set boundaries in terms of team organization, usage within specific parts of the application, and physical manifestations such as code bases and database schemas. Keep the model strictly consistent within these bounds, but don’t be distracted or confused by issues outside.</p><p>A analogia do círculo é péssima porque ela foca em uma caixa-preta, que não é um Módulo em Domain-Driven Design. Em DDD um módulo é quase que exatamente como um pacote em Java ou namespace em C#. O Contexto é dividido em Módulos, que agrupam entidades com conceitos em comum. A comunicação entre Contextos e entre Módulos é dada através de diversos padrões e técnicas.</p><p>Existe uma confusão também com Value Object. Em DDD um Value Object é <strong>um conceito de domínio como qualquer Entidade</strong> a diferença é que ele não tem identidade própria. Se eu pegar uma nota de dez reais emprestado de você você não exige que eu te devolva a mesma nota, apenas que devolva uma nota <strong>de mesmo valor ou equivalente</strong>. Este conceito do “mesmo valor” é o coração do Pattern. O tópico coloca o pobre VO como um TO, mero agrupamento de dados.</p><p>A parte da transação também é muito complicada. Desde o início deste século que nós estamos separando estas responsabilidades (autenticação, transações, log, etc.) como <strong>conceitos ortogonais</strong>. Conceitos ortogonais não devem, quando a tecnologia permite, estar implementados junto com regras de negócio, junto com entidades de domínio. Para isso suamos a AOP expressa por ferramentas como Spring Framework ou EJB (seja 2.1 ou 3.0). Eric Evans fala sobre separação entre domínio e tecnologia:</p><p>The domain model is a set of concepts. The “domain layer” is the manifestation of that model and all directly related design elements. The design and implementation of business logic constitute the domain layer. In a MODEL-DRIVEN DESIGN, the software constructs of the domain layer mirror the model concepts.</p><p>It is not practical to achieve that correspondence when the domain logic is mixed with other concerns of the program. Isolating the domain implementation is a prerequisite for domain-driven design.</p><p>Falar que ActiveRecord não funciona é negar a realidade. Frameworks como <a href="http://web.archive.org/web/20090212110155/http://www.rubyonrails.org/">Ruby on Rails</a>, <a href="http://web.archive.org/web/20090212110155/http://www.castleproject.org/">Castle</a> e <a href="http://web.archive.org/web/20090212110155/http://grails.codehaus.org/">Grails</a> se baseiam nele, não é porque não até até então nenhuma proposta Java de framework que o conceito não funciona. O exemplo dado não representa qualquer problema, já que transações são tratadas em um conceito ortogonal separado, como descrito acima. Se AR se aplica bem ou mal no caso X ou Y, com DDD ou o que for é outro assunto, que aliás já tratamos aqui mais de uma vez.</p><p>Interessante que toda a thread teria começado porque o autor original achou que <a href="http://web.archive.org/web/20090212110155/http://fragmental.com.br/wiki/">os artigos deste blog não são completos o suficiente</a>. Independente de serem (e não são) ou não, o que eu sempre recomendo é<strong>leia a bibliografia</strong>. Infelizmente tem (muita) gente que prefere simplesmente ter um pseudo-resumo rápido num fórum. Fazendo uma análise dos pontos que levantei aqui e de outros no texto em questão eu percebo que o autor original em si não teve muito sucesso em aprender os conceitos de Domain-Driven Design porque procurou o meio errado. Outro dia uma thread no mesmo fórum sobre o mesmo tema corria parecido, com uma pessoa fazendo críticas em cima de um modelo usando Repositórios. O problema é que o cidadão em questão nem sequer leu sobre a técnica antes de criticar, nem mesmo no <a href="http://web.archive.org/web/20090212110155/http://www.infoq.com/news/2006/12/domain-driven-design">resumo disponível gratuitamente</a> apenas pedia um exemplo como se quatro linhas de código fossem passar 500 páginas de conhecimento. O mundo tem pressa e preguiça, mas até onde isso leva?</p></body></html>