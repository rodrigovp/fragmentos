<html><head><title>Permanent Link to Confundindo DSLs</title><meta charset="utf-8"></head><body><h2>Permanent Link to Confundindo DSLs</h2><p>O <a href="http://web.archive.org/web/20090211221146/http://edgarsilva.com.br/?p=83">Edgar Silva escreveu um post sobre DSLs</a> há alguns dias. Deixei um comentário mas ao que parece ele não foi aprovado, logo resolvi postar algo para esclarecer uma confusão.</p><p>O Edgar anda mexendo com o antigo <a href="http://web.archive.org/web/20090211221146/http://docs.codehaus.org/display/DROOLS/Home">Drools</a>, atual JBoss Rules, que é uma <em>rule engine</em> bem famosa. A confusão do post pode ser sumarizada em:</p><p>Sendo assim podemos criar uma Domain Specific Language (DSL), uma linguagem que especifica para usuários, onde eles possam entender o que está acontecendo nas regras de negócio do sistema. É mais ou menos isso que o projeto que estou ajudando tem que fazer, então vamos a um pequeno exemplo: PT_BR.dsl</p><p>Daí seguindo para um exemplo de programação em português:</p><p><code><br> JAVA:</code></p><p><code> 1. Imprima "{msg}"=System.out.println("{msg}")<br> 2. [when]A quantidade produto igual a {value}=p : Produto( estoque =={value})<br> 3. [then]Chame o comando de continuação de Produto=p.<br> </code></p><p>(quem <a href="http://web.archive.org/web/20090211221146/http://www.meiobit.com/miscelaneas/cara_microsoft_traduzir_demais_atrapalha">já programou em VBA em português como eu deve ficar apavorado</a> vendo isso)</p><p>A confusão está no fato de que DSLs são linguagens específicas do domínio, não do usuário. Ter uma linguagem de programação em português não faz dela uma DSL. ter uma linguagem declarativa não faz dela uma DSL. Uma DSL vai mapear conceitos do domínio 9venda, estoque, etc.) para dentro dos construtos da linguagem, logo <strong>o exemplo não representa uma DSL</strong>, apenas uma customização em cima de uma rule engine.</p><p>Eu tenho um exemplo que sempre uso em palestras e costuma ser bem claro: Muita gente programa de maneira razoavelmente OO em C e Pascal. O que estas pessoas fazem é definir estrutruas de dados e funções num mesmo módulo (um arquivo .h e um .c em C, por exemplo) e fazem com que todo acesso aos dados sejam encapsulados com funções. Uma pessoa que conheça a paradigma de OO pode criar só com estas técnicas simples programas muitos mais orientados a objetos do que os criados com Java atualmente, com os tais BOs e VOs/TOs que são tudo, menos objetos.</p><p>O que eles fazem é mapear um conceito do domínio para a linguagem (sim, <a href="http://web.archive.org/web/20090211221146/http://fragmental.com.br/blog/?p=313">isso parece com DDD</a>), funciona que é uma beleza.</p><p>Mas existem linguagens que já trazem este conceito dentro de si. Em Java ou C# você não rpecisa desta gambiarra para utilizar objetos, basta você utilizar construtos da linguagem como a palavra reservada <code>class</code>. O domínio ‘Orientação a Objetos’ está mapeado dentro da linguagem.</p><p>SQL é outro bom exemplo. É uma linguagem específica para consultas e manipulação de bases de dados, você não constrói qualquer tipo de sofwtare com ela (a menos que utilize extensões bizarras do seu fornecedor de SGBD). Os conceitos de tabela, índice, chave, etc. estão dentro da linguagem.</p><p>Hoje ao modelar um sistema de gerência de estoque você não faz mais do que trazer aquele domínio para seu sistema através de um mapeamento de conceitos. O estoque do mundo real vira um bando de classes e atributos. Numa DSL o estoque do mundo real será representado por um construto ‘estoque’ na linguagem utilizada.</p><p><strong>Update:</strong> O Edgard autorizou o comentário, eu bem sei como é esta coisa de ter que moderar WordPress :P, segue abaixo:</p><p> Phillip Calçado “Shoes”</p><p>Uma DSL na verdade é uma técnica utilizada para trazer os conceitos de um determinado domínio para o sistema. É como ao invés de implementar OO utilziando C você utilize Java, que possui construtos como classes, modificadores de acesso e interfaces que expressam os conceitos de uma modelagem OO na linguagem ao invés de simular estes em structs e funções.</p><p>Apesar de auxiliar na definição de uma ubiquitous language, o objetivo do uso de DSL é diminuir o gap entre implementação e conceito do mundo real, não necessariamente o uso de linguagem natural.</p><p>A listagem mostrada é um curto exemplo mas na verdade traz os conceitos de um domínio, apenas utiliza uma linguagem imperativa mais natural e em português para a definição de regras de negócio, o que não é uma DSL. Na verdade DSLs não dizem anda sobre a sintaxe, se é declarativa ou imperativa ou qualquer outra coisa, ela apenas define uma linguagem que é utilizada para modelar um domínio específico, como gerência de estoque.</p><p>Para ser uma DSL teríamos conceitos como produto e estoque implementados como construtos da linguagem utilizada, exemplos e um ótimo texto do Fowler em:</p><p>http://martinfowler.com/articles/languageWorkbench.html</p><p>BPM, ESB, SOA e toda a parafernalha correlata não implicam em DSLs, na verdade não existe nenhuma ligação exceto que implementações como o mencionado Jboss Rules/Drools trazem alguns recursos para implementar mini-linguagens. Infelizmente ainda estão bem longe do ideal, na verdade a Microsoft tem uma linha de produtos antagônicos ao MDA que se aproxima mais do que se esperaria de uma LanguageWorkbench:</p><p>http://msdn2.microsoft.com/en-us/teamsystem/aa718951.aspx</p><p>No lado Java existem empresas que estão construindo seus workbenches, entre elas a JetBrains:</p><p>http://www.jetbrains.com/mps/<br> http://www.metacase.com/ </p></body></html>